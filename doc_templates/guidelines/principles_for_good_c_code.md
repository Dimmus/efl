# 47 Атрибутов Хорошего С-кода

@author: aabzel \
@date 27 июля \
@link: https://habr.com/ru/hub/programming/

## 7

Не вставлять функции внутрь `if()`. Коды возврата приходится анализировать пошаговым отладчиком до проверки условия.

это очень плохо:
```C
if (MmGet(ID_IPv4_ROLE, tmp, 1, &tmp_len) != MM_RET_CODE_OK) {
    return ERROR_CODE_HARDWARE_FAULT;
}
```

Надо писать код так, чтобы было возможно его проверять пошаговым отладчиком. Поэтому каждое элементарное действие должно быть на одной строке. Вот так уже гораздо лучше.
```C
int ret = MmGet(ID_IPv4_ROLE, tmp, 1, &tmp_len);
if (ret != MM_RET_CODE_OK) {
    return ERROR_CODE_HARDWARE_FAULT;
}
```

## 8

Использовать static функции везде, где только можно. Это повысит модульность.

## 15

Все Си-функции должны всегда возвращать код ошибки. Минимум тип bool или числовой код ошибки. Так можно понять, где именно что-то пошло не так. Проще говоря, не должно быть функций, которые возвращают void. Функции void это, по факту, бомбы с часовым механизмом. В один день они отработают ошибочно, а вы об этом ничего даже не узнаете.

## 17

Если функция получает указатель, то пусть сразу проверяет на нуль значение указателя. Так прошивки не будут падать при получении нулевых указателей. Это повысит надежность кода. Вы же не знаете как и кто этот код будет испытывать. Хорошая функция всегда проверяет то, что ей дают.

## 26

Скрывать область видимости локальных переменных по максимуму.

## 28

Если вы в С передаете что-то через указатель или возвращаете через указатель, то указываете направление движения данных приставками `in`, `io` или `out`.

Например:
```C
void ProcSomeData(unsigned char* in_buffer,
                  unsigned char* out_buffer, 
                  int len, 
                  int *out_len);
```
Это позволит легче читать прототипы, не погружаясь в тело функции.

## 33

Все `.h` файлы снабжать защитой препроцессора от повторного включения. 

## 37

Делать автоматическое форматирование отступов исходного кода. Подойдет например бесплатная утилита clang-format или GNUIndent. Это позволит делать простые выражения при поиске по коду утилитой grep. И будет минимальный diff при сравнении истории файлов. Придерживаться какого-нибудь одного стиля форматирования. Пусть будет "единообразно безобразно".

## 44

Прогонять кодовую базу через статический анализатор. Хотя бы бесплатный CppCheck. Может, найдется очередная загвоздка.

## 45

За if, for ... всегда должны быть { }. Весьма вероятно, что условие будет пополнено операторами.

## 46

Include(ы) всегда должны только содержать только название конечного файла. Include(ы) не должны содержать часть пути к файлу.

Таким образом вы сможете спокойно перетасовывать файлы в папках проекта и проект по- прежнему будет собираться. И визуально это намного легче читать, поддерживать. А сами пути к заголовочным файлам надо передавать через опцию `-I` компилятора через make файлы. В коде же `#include`(ы) должны быть максимально короткими.

## 47

Если вы определяете глобальную структуру, то указывайте имя полей. Так это продолжит работать, если кто-нибудь вдруг решится поменять порядок полей в структуре.

неправильно
```C
const LedConfig_t LedConfig[LED_CNT] = {
       {LED_GREEN_ID,   1000, 0, 60, PORT_C, 13,"Green", LED_MODE_PWM, true,},
};
```

правильно
```C
const LedConfig_t LedConfig[LED_CNT] = {
       {.num=LED_GREEN_ID,   
        .period_ms=1000, 
        .phase_ms=0, 
        .duty=60,
        .pad.port=PORT_C,
        .pad.pin=13, 
        .name="Green",
        .mode=LED_MODE_PWM, 
        .valid=true,},
  
};
```

## 

BAD: Макросы маленькими буквами



